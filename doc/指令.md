# 指令
## 内置指令
### `v-text`
**`<div v-text="count + 1"></div>`**
```js
const _hoisted_21 = ["textContent"]
createElementVNode("div", {
  textContent: _toDisplayString(_ctx.count + 1)
}, null, 8 /* PROPS */, _hoisted_21)
```

### `v-html`
**`<div v-html="htmlStr"></div>`**
```js
createElementVNode("div", {
  innerHTML: _ctx.htmlStr
}, null, 8 /* PROPS */, _hoisted_20)
```

### `v-show`
**`<div v-show="isShow">v-show-text</div>`**
```ts
_withDirectives(
  _createElementVNode("div", null, "v-show-text", 512 /* NEED_PATCH */), [
    [_vShow, _ctx.isShow]
  ]
)
// runtime-core/src/directives.ts
function withDirectives<T extends VNode>(
  vnode: T,
  directives: DirectiveArguments,
): T {
  if (currentRenderingInstance === null) {
    return vnode
  }
  const instance =
    (getExposeProxy(currentRenderingInstance) as ComponentPublicInstance) ||
    currentRenderingInstance.proxy
  const bindings: DirectiveBinding[] = vnode.dirs || (vnode.dirs = [])
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i]
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir,
        } as ObjectDirective
      }
      if (dir.deep) {
        traverse(value)
      }
      bindings.push({
        dir, // vShow = { bM, m, u, buM }
        instance,
        value, // _ctx.isShow
        oldValue: void 0,
        arg,
        modifiers,
      })
    }
  }
  return vnode
}
const vShow: ObjectDirective<VShowElement> & { name?: 'show' } = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] =
      el.style.display === 'none' ? '' : el.style.display
    if (transition && value) {
      transition.beforeEnter(el)
    } else {
      setDisplay(el, value)
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el)
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return
    if (transition) {
      if (value) {
        transition.beforeEnter(el)
        setDisplay(el, true)
        transition.enter(el)
      } else {
        transition.leave(el, () => {
          setDisplay(el, false)
        })
      }
    } else {
      setDisplay(el, value)
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value)
  },
}
```

### `v-if` `v-else-if` `v-else`
```html
<div v-if="ifVal === 'isIf'">v-if-text</div>
<div v-else-if="ifVal === 'isElseIf'">v-else-if-text</div>
<div v-else="ifVal === 'isElse'">v-else-text</div>
```
```ts
const _hoisted_22 = { key: 0 }
const _hoisted_23 = { key: 1 }
const _hoisted_24 = { key: 2 }
(_ctx.ifVal === 'isIf')
  ? (_openBlock(), _createElementBlock("div", _hoisted_22, "v-if-text"))
  : (_ctx.ifVal === 'isElseIf')
    ? (_openBlock(), _createElementBlock("div", _hoisted_23, "v-else-if-text"))
    : (_openBlock(), _createElementBlock("div", _hoisted_24, "v-else-text"))
```

### `v-for`
**`<div v-for="(item, index) in arr" :key="item">{{ `${item}-${index}` }}</div>`**
```ts
(_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_ctx.arr, (item, index) => {
      return (_openBlock(), _createElementBlock("div", { key: item }, _toDisplayString(`${item}-${index}`), 1 /* TEXT */))
    }), 128 /* KEYED_FRAGMENT */))
```

### `v-on`

### `v-bind`

### `v-model`

### `v-slot`

### `v-pre`

### `v-once`

### `v-memo`

### `v-cloak`
